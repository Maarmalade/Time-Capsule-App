rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions for authentication and validation
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isValidUsername(username) {
      return username is string && 
             username.size() >= 3 && 
             username.size() <= 30 &&
             username.matches('^[a-zA-Z0-9_]+$');
    }
    
    // Users collection - extended for social features and FCM tokens
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isOwner(userId) && 
                      (request.resource.data.keys().hasAll(['email', 'username']) &&
                       isValidUsername(request.resource.data.username));
      
      // Allow FCM token updates
      allow update: if isOwner(userId) && 
                       request.writeFields.hasOnly(['fcmToken', 'fcmTokenUpdatedAt', 'platform']);
    }
    
    // Friend Requests collection
    match /friendRequests/{requestId} {
      // Users can read their own sent or received friend requests
      allow read: if isAuthenticated() && 
                     (resource.data.senderId == request.auth.uid || 
                      resource.data.receiverId == request.auth.uid);
      
      // Users can create friend requests where they are the sender
      allow create: if isAuthenticated() && 
                       request.resource.data.senderId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['senderId', 'receiverId', 'senderUsername', 'status', 'createdAt']) &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.senderId != request.resource.data.receiverId;
      
      // Users can update friend requests where they are the receiver (accept/decline)
      allow update: if isAuthenticated() && 
                       resource.data.receiverId == request.auth.uid &&
                       resource.data.status == 'pending' &&
                       request.resource.data.status in ['accepted', 'declined'];
      
      // No delete operations allowed - maintain audit trail
      allow delete: if false;
    }
    
    // Friendships collection
    match /friendships/{friendshipId} {
      // Users can read friendships where they are one of the participants
      allow read: if isAuthenticated() && 
                     (resource.data.userId1 == request.auth.uid || 
                      resource.data.userId2 == request.auth.uid);
      
      // Allow friendship creation when accepting friend requests
      // This is triggered by the friend service when a request is accepted
      allow create: if isAuthenticated() && 
                       (request.resource.data.userId1 == request.auth.uid || 
                        request.resource.data.userId2 == request.auth.uid) &&
                       request.resource.data.userId1 != request.resource.data.userId2;
      
      // No updates allowed - friendships are immutable once created
      allow update: if false;
      
      // Users can delete friendships where they are one of the participants
      allow delete: if isAuthenticated() && 
                       (resource.data.userId1 == request.auth.uid || 
                        resource.data.userId2 == request.auth.uid);
    }    

    // Helper functions for folder access control
    function isContributor(folderId) {
      return isAuthenticated() && 
             request.auth.uid in resource.data.contributorIds;
    }
    
    function isFolderOwner(folderId) {
      return isAuthenticated() && 
             request.auth.uid == resource.data.userId;
    }
    
    function canAccessFolder() {
      return isFolderOwner(resource.id) || 
             isContributor(resource.id) || 
             resource.data.isPublic == true ||
             canAccessParentFolder();
    }
    
    function canModifyFolder() {
      return isFolderOwner(resource.id) || 
             (isContributor(resource.id) && resource.data.isLocked != true) ||
             canModifyParentFolder();
    }
    
    function canAccessParentFolder() {
      return resource.data.parentFolderId != null &&
             exists(/databases/$(database)/documents/folders/$(resource.data.parentFolderId)) &&
             (get(/databases/$(database)/documents/folders/$(resource.data.parentFolderId)).data.userId == request.auth.uid ||
              request.auth.uid in get(/databases/$(database)/documents/folders/$(resource.data.parentFolderId)).data.get('contributorIds', []) ||
              get(/databases/$(database)/documents/folders/$(resource.data.parentFolderId)).data.get('isPublic', false) == true);
    }
    
    function canModifyParentFolder() {
      return resource.data.parentFolderId != null &&
             exists(/databases/$(database)/documents/folders/$(resource.data.parentFolderId)) &&
             (get(/databases/$(database)/documents/folders/$(resource.data.parentFolderId)).data.userId == request.auth.uid ||
              (request.auth.uid in get(/databases/$(database)/documents/folders/$(resource.data.parentFolderId)).data.get('contributorIds', []) &&
               get(/databases/$(database)/documents/folders/$(resource.data.parentFolderId)).data.get('isLocked', false) != true));
    }
    
    function canCreateNestedFolder() {
      return request.resource.data.parentFolderId == null ||
             (exists(/databases/$(database)/documents/folders/$(request.resource.data.parentFolderId)) &&
              (get(/databases/$(database)/documents/folders/$(request.resource.data.parentFolderId)).data.userId == request.auth.uid ||
               (request.auth.uid in get(/databases/$(database)/documents/folders/$(request.resource.data.parentFolderId)).data.get('contributorIds', []) &&
                get(/databases/$(database)/documents/folders/$(request.resource.data.parentFolderId)).data.get('isLocked', false) != true)));
    }
    
    // Folders collection - extended for shared and public functionality
    match /folders/{folderId} {
      // Read access: owner, contributors, or anyone if public
      allow read: if isAuthenticated() && canAccessFolder();
      
      // List access: authenticated users can query folders
      // Note: This allows the query but individual documents are still filtered by read rules
      allow list: if isAuthenticated();
      
      // Create access: users can create their own folders or nested folders in shared folders
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['name', 'userId', 'createdAt']) &&
                       canCreateNestedFolder();
      
      // Update access: owner can always update, contributors can update if not locked
      allow update: if isAuthenticated() && canModifyFolder() &&
                       // Prevent contributors from changing critical folder settings
                       (isFolderOwner(folderId) || 
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'description', 'coverImageUrl']));
      
      // Delete access: only owner can delete
      allow delete: if isAuthenticated() && isFolderOwner(folderId);
      
      // Media subcollection within folders
      match /media/{mediaId} {
        // Temporarily very permissive rules to debug the issue
        // Read access: all authenticated users
        allow read: if isAuthenticated();
        
        // List access: all authenticated users
        allow list: if isAuthenticated();
        
        // Create access: all authenticated users (temporarily very permissive)
        allow create: if isAuthenticated();
        
        // Update access: all authenticated users (temporarily very permissive)
        allow update: if isAuthenticated();
        
        // Delete access: all authenticated users (temporarily very permissive)
        allow delete: if isAuthenticated();
      }
    }  
  
    // Scheduled Messages collection
    match /scheduledMessages/{messageId} {
      // Read access: sender or recipient only
      allow read: if isAuthenticated() && 
                     (resource.data.senderId == request.auth.uid || 
                      resource.data.recipientId == request.auth.uid);
      
      // Create access: authenticated users can create messages where they are the sender
      allow create: if isAuthenticated() && 
                       request.resource.data.senderId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['senderId', 'recipientId', 'textContent', 'scheduledFor', 'createdAt', 'status']) &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.scheduledFor > request.time &&
                       request.resource.data.textContent is string &&
                       request.resource.data.textContent.size() > 0 &&
                       request.resource.data.textContent.size() <= 5000; // 5KB text limit
      
      // Update access: only system (Cloud Functions) can update delivery status
      // Users can only cancel their own pending messages
      allow update: if isAuthenticated() && 
                       resource.data.senderId == request.auth.uid &&
                       resource.data.status == 'pending' &&
                       request.resource.data.status == 'cancelled' &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']);
      
      // Delete access: sender can delete their own pending messages
      allow delete: if isAuthenticated() && 
                       resource.data.senderId == request.auth.uid &&
                       resource.data.status == 'pending';
    }



    // FCM Tokens collection
    match /fcm_tokens/{tokenId} {
      // Read access: users can only read their own tokens
      // Allow document ID to be either userId or userId_platform format
      allow read: if isAuthenticated() && 
                     (resource.data.userId == request.auth.uid ||
                      tokenId == request.auth.uid ||
                      tokenId.matches('^' + request.auth.uid + '_.*'));
      
      // Create access: users can create tokens for themselves
      // Allow any document ID format as long as the user owns the token
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId', 'token', 'lastUpdated', 'platform']) &&
                       request.resource.data.token is string &&
                       request.resource.data.token.size() > 0 &&
                       request.resource.data.platform is string &&
                       request.resource.data.platform in ['android', 'ios', 'web', 'windows', 'macos', 'linux'] &&
                       (tokenId == request.auth.uid || tokenId.matches('^' + request.auth.uid + '_.*'));
      
      // Update access: users can update their own tokens
      allow update: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid &&
                       (tokenId == request.auth.uid || tokenId.matches('^' + request.auth.uid + '_.*'));
      
      // Delete access: users can delete their own tokens
      allow delete: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid &&
                       (tokenId == request.auth.uid || tokenId.matches('^' + request.auth.uid + '_.*'));
    }
  }
}